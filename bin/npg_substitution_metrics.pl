#!/usr/bin/env perl

# Author:        Irina Abnizova & Steven Leonard
# Created:       2021-04-12
#
# script which reads a substitution report generated by bambi substitution_analysis and generates some metrics
# 
# Flags:
#  -h : help
#  -v : verbose
#  -o <output_file> : [OPTIONAL] Specify output file name (default is metrics.txt)
#

use strict;
use warnings;
use FindBin qw($Bin);
use lib ( -d "$Bin/../lib/perl5" ? "$Bin/../lib/perl5" : "$Bin/../lib" );

use Getopt::Long;

use File::Slurp;
use FileHandle;
use Math::Round;
use Statistics::Lite qw(:all);

##no critic
our $VERSION = '0';

main();
0;

sub main {
  my $opts = get_options();

  my $err_file = shift(@ARGV);

  my $tags = [qw(SET RCH RCL PRCNH PRCNL)];

  my $err_data = read_err_file($err_file, $tags);

  if ($opts->{'verbose'}) {
    printf("maximal quality $err_data->{maQ}\n") if exists($err_data->{maQ});
    printf("number of cycles $err_data->{ncyc}\n") if exists($err_data->{ncyc});
    if (exists($err_data->{rch})) {
      my %coH1 = %{$err_data->{rch}->{1}->{-1}};
      printf("counts of HQ substitutions R1");
      foreach (sort keys %coH1) {
        print "\t$_:$coH1{$_}";
      }
      print "\n";
    }
  }

  my $metrics = metrics_gen_assym_prediction($err_data, $opts->{verbose});

  if ($opts->{'verbose'}) {
    printf("GT_meTi $metrics->{GT_meTi}\n");
    printf("likelihood of C2A $metrics->{likelihood}\n");
  }

  write_metrics_file( $metrics, $opts->{output});

  return;
}

# process command line options
sub get_options() {

  my $usage = qq[

  Usage:
    
         npg_substitution_metrics.pl <opts> file

  Options:

         -o <file>     output file, default metrics.txt
         -v            verbose
         -h            help

  ];

  my %options = (verbose => 0, output => 'metrics.txt');

  my $result = GetOptions(\%options,
                          "output:s",
                          "verbose",
                          "help"
                          );

  die("$usage\n") if( !$result || $options{help} || scalar(@ARGV) < 1);

  return \%options;
}

# read error file
sub read_err_file () {
  my ($file, $tags) = @_;

  my @lines = read_file($file);
  die "No data in $file\n" unless @lines;

  my %err_data = ();

  foreach my $tag (@{$tags}) {
    if ( $tag eq 'SET' ) {
       $err_data{set} = read_set_tag(\@lines, $tag);
       if ( scalar(keys %{$err_data{set}}) == 0 ) {
         print STDERR "No data in $file\n";
         exit(0);
       } 
       $err_data{maQ} = max(max(keys %{$err_data{set}->{1}}), max(keys %{$err_data{set}->{2}}));
    } elsif( $tag eq 'RCH' ) {
        $err_data{rch} = read_rc_tag(\@lines, $tag);
        $err_data{ncyc} = max(max(keys %{$err_data{rch}->{1}}), max(keys %{$err_data{rch}->{2}})) + 1;
    } elsif( $tag eq 'RCL' ) {
        $err_data{rcl} = read_rc_tag(\@lines, $tag);
    } elsif( $tag eq 'PRCNH' ) {
        $err_data{prcnh}= read_win_tag(\@lines, $tag);
    } elsif( $tag eq 'PRCNL' ) {
        $err_data{prcnl}= read_win_tag(\@lines, $tag);
    } else {
      die "Unknown tag $tag\n";
    }
  }

  return \%err_data;
}

# read set tag
sub read_set_tag() {
  my ($lines, $tag) = @_;

  die "Error: reading tag $tag as a SET tag\n" unless $tag =~ m/^SET$/;

  my %set = ();

  foreach my $line (@{$lines}) {
    next unless $line =~ m/^$tag/;

    my @fields = split(/\s+/, $line);
    my ($ctag, $read, $qual) = splice(@fields, 0, 3);
    my %counts = @fields;

    $set{$read}->{$qual}=\%counts;
  }

  return \%set;
}

# read rc tag
sub read_rc_tag() {
  my ($lines, $tag) = @_;

  die "Error: reading tag $tag as a RC tag\n" unless $tag =~ m/^RC[HL]$/;

  my %rc= ();

  foreach my $line (@{$lines}) {
    next unless $line =~ m/^$tag/;

    my @fields = split(/\s+/, $line);
    my ($ctag, $read, $cycle) = splice(@fields, 0, 3);
    my %counts = @fields;

    $rc{$read}->{$cycle}=\%counts;
  }

  return \%rc;
}

# read win tag
sub read_win_tag() {
  my ($lines, $tag) = @_;

  die "Error: reading tag $tag as a WIN tag\n" unless $tag =~ m/^PRCN[HL]$/;

  my %win= ();

  foreach my $line (@{$lines}) {
    next unless $line =~ m/^$tag/;

    my @fields = split(/\s+/, $line);
    my ($ctag, $read) = splice(@fields, 0, 2);
    my %counts = @fields;

    $win{$read}=\%counts;
  }

  return \%win;
}

# generate metrics
sub metrics_gen_assym_prediction () {
  my ($err_data, $verbose) = @_;

  # for now, hard code thresholds
  my $thr_ass = 1; # strand assymetry
  my $thr_art = 0.8;
  my $thr_cv = 0.1;

  my %results = (
    likelihood => -1,
    predict    => -1,
    art_ox     => -1,
    cvTi       => -1,
    symm_ct_ga => -1,
    symm_ag_tc => -1,
    TiTv       => -1,
    TiTv_meGT  => -1,
    bias_ox    => -1,
    symm_gt_ca => -1,
    GT_meTi    => -1,
    gt_nearTi  => -1,
    fracHall   => -1
  );

  my @ti = qw(AG CT GA TC);
  my @tv = qw(AC AT CA CG GC GT TA TG);

  # we only require the read summaries (cycle=-1), make local copies as we may modify them later 
  my %coH1 = %{$err_data->{rch}->{1}->{-1}};
  my %coH2 = %{$err_data->{rch}->{2}->{-1}};
  my %coL1 = %{$err_data->{rcl}->{1}->{-1}};
  my %coL2 = %{$err_data->{rcl}->{2}->{-1}};

  unless (%coH1 && %coH2) {
    return \%results;
  }

  #1----------------------Ti variability and symmetry

  #1.1---------------------------Ti symmetry

  #1.1.1 ---assymetry(sh be symmetry)mis =min separated pair Ti: AG TC
  my $mis1 = min(($coH1{AG}, $coH1{TC}));
  my $mis2 = min(($coH2{AG}, $coH2{TC}));

  #----------------as= asymetry of 'separated' Ti
  my $as_ag_tc_R1 = ($mis1 > 0 ? (abs($coH1{AG} - $coH1{TC}) / $mis1) : 0);
  my $as_ag_tc_R2 = ($mis2 > 0 ? (abs($coH2{AG} - $coH2{TC}) / $mis2) : 0);
  my $symm_ag_tc = max(($as_ag_tc_R1, $as_ag_tc_R2));

  #1.1.2 ---- strand assymetry (sh be symmetry) mic=min 'close' Ti: CT GA
  my $mic1 = min(($coH1{CT}, $coH1{GA}));
  my $mic2 = min(($coH2{CT}, $coH2{GA}));
  my $as_ct_ga_R1 = ($mic1 > 0 ? (abs($coH1{CT} - $coH1{GA}) / $mic1) : 0);
  my $as_ct_ga_R2 = ($mic2 > 0 ? (abs($coH2{CT} - $coH2{GA}) / $mic2) : 0);
  my $symm_ct_ga = max(($as_ct_ga_R1, $as_ct_ga_R2));

  my @ti1 = ($coH1{AG}, $coH1{TC}, $coH1{CT}, $coH1{GA});
  my $mean_ti1 = round(mean(@ti1));
  my $sd_ti1 = round(stddev(@ti1));

  my @ti2 = ($coH2{AG}, $coH2{TC}, $coH2{CT}, $coH2{GA});
  my $mean_ti2 = round(mean(@ti2));
  my $sd_ti2 = round(stddev(@ti2));

  #-----------------cvTi
  my $cvTi1 = ($mean_ti1 > 0 ? ($sd_ti1 / $mean_ti1) : 0);
  my $cvTi2 = ($mean_ti2 > 0 ? ($sd_ti2 / $mean_ti2) : 0);
  my $cvTi = max(($cvTi1, $cvTi2));

  my ($Ti1, $Ti2, $Tv1, $Tv2) = (0, 0, 0, 0);
  map {$Ti1 += $coH1{$_}} @ti;
  map {$Ti2 += $coH2{$_}} @ti;
  map {$Tv1 += $coH1{$_}} @tv;
  map {$Tv2 += $coH2{$_}} @tv;

  my $TiTv1 = ($Tv1 > 0 ? ($Ti1 / $Tv1) : 0);
  my $TiTv2 = ($Tv2 > 0 ? ($Ti2 / $Tv2) : 0);
  my $TiTv = max(($TiTv1, $TiTv2));

  #2.2-======------------------TiTv with mddean GT CA across other Tv

  my %coH11 = %coH1;
  my %coH22 = %coH2;

  #------------------actually, CA and GT sh be as other Ti= mean of them
  my @other_Tv1 = ($coH11{AC}, $coH11{AT}, $coH11{CG}, $coH11{GC}, $coH11{TA}, $coH11{TG});
  my $meTv1 = mean(@other_Tv1);
  $coH11{CA} = $meTv1;
  $coH11{GT} = $meTv1;
  my @other_Tv2 = ($coH22{AC}, $coH22{AT}, $coH22{CG}, $coH22{GC}, $coH22{TA}, $coH22{TG});
  my $meTv2 = mean(@other_Tv2);
  $coH22{CA} = $meTv2;
  $coH22{GT} = $meTv2;

  my ($si1, $si2, $sv1, $sv2) = (0, 0, 0, 0);
  map {$si1 += $coH11{$_}} @ti;
  map {$si2 += $coH22{$_}} @ti;
  map {$sv1 += $coH11{$_}} @tv;
  map {$sv2 += $coH22{$_}} @tv;

  my $si_sv1 = ($sv1 > 0 ? ($si1 / $sv1) : 0);
  my $si_sv2 = ($sv2 > 0 ? ($si2 / $sv2) : 0);
  my $TiTv_meGT = max(($si_sv1, $si_sv2));

  #3========metrics on oxiG and GT/CA artefact
  #artefact C2A=art_ox=proportion of gt/ca to mean Ti, depends on Ti variability 

  #===============art_ox=proportion of gt or ca to mean Ti
  my $ma1 = max(($coH1{CA}, $coH1{GT}));
  my $ma2 = max(($coH2{CA}, $coH2{GT}));

  # prop max(gt,ca) in Ti: the higher the more likely artC2A
  my $artR1 = ($mean_ti1 > 0 ? ($ma1 / $mean_ti1) : 0);
  my $artR2 = ($mean_ti2 > 0 ? ($ma2 / $mean_ti2) : 0);
  my $art_ox = max(($artR1, $artR2));

  #3.2 ----------------------oxidation biasas BROAD
  #BROAD found CCG->CAG and GT more at R1, CA more at R2
  my ($bR1, $bR2) = (-1, -1);
  if ($coH1{CA} > 0 && $coH2{GT} > 0) {
    $bR1 = abs(($coH1{GT} - $coH1{CA}) / $coH1{CA}); # divided by expected smaller- check the paper
    $bR2 = abs(($coH2{GT} - $coH2{CA}) / $coH2{GT}); # divided by expected smaller- check the paper
  }
  my $bias_ox = max(($bR1, $bR2));

  #3.3-----------GT assymmetry
  #here we look at strand assymetry (sh be symmetry), in contrast to BROAD
  my $mi1 = min(($coH1{CA}, $coH1{GT}));
  my $mi2 = min(($coH2{CA}, $coH2{GT}));

  my ($b1, $b2) = (-1, -1);
  if ($mi1 > 0 && $mi2 > 0) {
    $b1 = abs($coH1{GT} - $coH1{CA}) / $mi1; # divided by smaller- not as in the paper
    $b2 = abs($coH2{GT} - $coH2{CA}) / $mi2;
  }
  my $symm_gt_ca = max(($b1, $b2));

  #3.4---------GT/TC relation to TC (the closest Ti) OR CA to AG

  my $gt_tc_1 = ($coH1{TC} > 0 ? ($coH1{GT} / $coH1{TC}) : 0);
  my $gt_tc_2 = ($coH2{TC} > 0 ? ($coH2{GT} / $coH2{TC}) : 0);
  my $ca_ag_1 = ($coH1{AG} > 0 ? ($coH1{CA} / $coH1{AG}) : 0);
  my $ca_ag_2 = ($coH2{AG} > 0 ? ($coH2{CA} / $coH2{AG}) : 0);

  my $gt_nearTi = max((max(($gt_tc_1,$ca_ag_1)),max(($gt_tc_2,$ca_ag_2))));

  #3.5---------------------GT to meanTi
  my $GT_meTi1 = ($mean_ti1 > 0 ? ($coH1{GT} / $mean_ti1) : 0);
  my $GT_meTi2 = ($mean_ti2 > 0 ? ($coH2{GT} / $mean_ti2) : 0);
  my $GT_meTi = max(($GT_meTi1, $GT_meTi2));

  #4=======----------fracHall
  my $sum1 = sum(values %coL1) + sum(values %coH1);
  my $fracHL1 = ($sum1 > 0 ? (sum(values %coH1) / $sum1) : 0);
  my $sum2 = sum(values %coL2) + sum(values %coH2);
  my $fracHL2 = ($sum2 > 0 ? (sum(values %coH1) / $sum2) : 0);
  my $fracH = round(100.0 * max(($fracHL1, $fracHL2)));

  my $sum12= sum(values %coL1) + sum(values %coH1) + sum(values %coL2) + sum(values %coH2);
  my $fracHL1a = ($sum12 > 0 ? (sum(values %coH1) / $sum12) : 0);
  my $fracHL2a = ($sum12 > 0 ? (sum(values %coH2) / $sum12) : 0);
  my $fracHall = max(($fracHL1a, $fracHL2a));

  #5---------------predictions and prolly based on likelihood of art-ox
  my $pred_high = 3;
  my $pred_med = 2;
  my $pred_low = 1;
  my $pred_no = 0;

  my $predict = -1;

  if ($art_ox >= $thr_art) {
     if ($verbose) {
       printf("likely C2A artefact %s\n", $art_ox);
     }
     $predict = predict_artefactOx_const($thr_art, $art_ox, $pred_low, $pred_med, $pred_high);
  } else {
     if ($verbose) {
       printf("not likely C2A artefact\n");
     }
     $predict = $pred_no;
  }

  #5.2--------compute probability/likelihood of C2A based on art_ox
  my $likely = $gt_nearTi;
  my $likelihood = $likely;

  # update results
  $results{likelihood} = $likelihood;
  $results{predict}    = $predict;
  $results{art_ox}     = $art_ox;
  $results{cvTi}       = $cvTi;
  $results{symm_ct_ga} = $symm_ct_ga;
  $results{symm_ag_tc} = $symm_ag_tc;
  $results{TiTv}       = $TiTv;
  $results{TiTv_meGT}  = $TiTv_meGT;
  $results{bias_ox}    = $bias_ox;
  $results{symm_gt_ca} = $symm_gt_ca;
  $results{GT_meTi}    = $GT_meTi;
  $results{gt_nearTi}  = $gt_nearTi;
  $results{fracHall}   = $fracHall;

  return \%results;
}

# predictor
sub predict_artefactOx_const() {
  my ($thr, $art_ox, $pred_low, $pred_med, $pred_high) = @_;

  my $predict = -1;

  my $thrM = $thr + 0.2;
  my $thrH = $thr + 0.6;

  if ($art_ox > $thrH) {
    $predict = $pred_high;
  } elsif($art_ox >= $thrM) {
    $predict = $pred_med;
  } elsif($art_ox >= $thr) {
    $predict = $pred_low;
  }

  return $predict;
}

# write_metrics_file
sub write_metrics_file () {
  my ($metrics, $file) = @_;

  my $level = -1;

  open FILE, ">$file" or die "Can't open $file : $!\n";

  printf FILE "#C2A related stats and metrics for a tag\n"; 
  printf FILE "TiTv_class %.2f\n", $metrics->{TiTv};
  printf FILE "TiTv_meCA %.2f\n",  $metrics->{TiTv_meGT};
  printf FILE "fracH %.2f\n",      $metrics->{fracHall};
  printf FILE "oxoGHbias %.2f\n",  $metrics->{bias_ox};
  printf FILE "symGT_CA %.2f\n",   $metrics->{symm_gt_ca};
  printf FILE "sym_ct_ga %.2f\n",  $metrics->{symm_ct_ga};
  printf FILE "sym_ag_tc %.2f\n",  $metrics->{symm_ag_tc};
  printf FILE "cvTi %.2f\n",       $metrics->{cvTi};
  printf FILE "GT_Ti %.2f\n",      $metrics->{gt_nearTi};
  printf FILE "GT_meTi %.2f\n",    $metrics->{GT_meTi};
  printf FILE "level %d\n",        $level;
  printf FILE "art_oxH %.2f\n",    $metrics->{art_ox};
  printf FILE "predict %d\n",      $metrics->{predict};

  close FILE;

  return;
}

=head1 CONFIGURATION

=head1 SYNOPSIS

=head1 DESCRIPTION

=head1 SUBROUTINES/METHODS

=head1 DIAGNOSTICS

=head1 CONFIGURATION AND ENVIRONMENT

=head1 REQUIRED ARGUMENTS

=head1 OPTIONS

=head1 EXIT STATUS

=head1 DEPENDENCIES

=over

=item strict

=item warnings

=item FindBin

=item Getopt::Long

=item File::Slurp

=item FileHandle

=item Math::Round

=item Statistics::Lite

=back

=head1 INCOMPATIBILITIES

=head1 BUGS AND LIMITATIONS

=head1 AUTHOR

Irina Abnizova<lt>ia1@sanger.ac.ukE<gt>

Steven Leonard<lt>srl@sanger.ac.ukE<gt>

=head1 LICENSE AND COPYRIGHT

Copyright (C) 2011 GRL, by Irina Abnizova & Steven Leonard

This file is part of NPG.

NPG is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut

